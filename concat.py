

#TODO if '__globals__' in module text, freak out
#TODO if encodings are different, fail

import modulefinder
import sys
import pprint

import py2depgraph

def get_deps_in_order(filename):
    mf = py2depgraph.mymf()
    mf.run_script(filename)
    depgraph = mf._depgraph
    pprint.pprint(depgraph)

    imported = []
    def mod_we_need(mod):
        if mod.__name__ in imported:
            return False
        if mod.__name__ in sys.builtin_module_names:
            return False
        if mod.__file__[-3:] == '.so':
            return False
        if 'site-packages' in mod.__file__:
            return True
        if '/lib/python' in mod.__file__:
            return False
        return True

    def leafgen(tree):
        for leaf in tree:
            mod = mf.modules[leaf]
            if not mod_we_need(mod):
                continue
            if tree[leaf] == 1:
                k = leaf
                yield k
            else:
                for innerleaf in leafgen(tree[leaf]):
                    yield innerleaf
                if mod_we_need(mf.modules[leaf]):
                    yield leaf

    def no_repeats(iterable):
        imported = []
        for k in iterable:
            if k in imported:
                pass
            else:
                imported.append(k)
                yield k

    for x in no_repeats(leafgen(depgraph)):
        print x

get_deps_in_order('./main.py')
sys.exit()

print get_deps_in_order('./main.py')


def concatenate(filename, method=None, output=None):
    finder = modulefinder.ModuleFinder(debug=0)
    finder.run_script(filename)
    # for module finder to work it has to be able to run the file and get everything it will need
    finder.report()
    print finder.modules

    #TODO figure out which modules are stdlib and which aren't
    #TODO figure out the order in which modules need to be loaded
    #TODO whine about globals

    build_main_file_with_module_objects(filename, finder.modules, output)

def build_main_file_with_module_objects(mainfile, modules, output):

    def module_template(name, filename):
        print name, filename
        indented_module_code = '\n'.join(
            ['    '+line if line else ''
                for line in open(filename).read().split('\n')])
        s = """
def create_module(): # just for the scope barrier
    MODULE = imp.new_module('{name}')
    __name__ = {name}
{indented_module_code}
    for k, v in locals().items():
        setattr(MODULE, k, v)
    return MODULE
sys.modules['{name}'] = create_module()
del create_module
""".format(name=name, indented_module_code=indented_module_code)
        return s

    main = '#Generated by concat.py\n'
    main += 'import imp\n'
    main += 'import sys\n'
    for name, module in modules.iteritems():
        main += module_template(name, module.__file__)
    main += '#main file\n'
    main += open(mainfile).read()
    open(output, 'w').write(main)

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('file')
    parser.add_argument('output', default='main.py')
    parser.add_argument('-m', '--method', choices=['correct', 'naive', 'nomodules'], default='naive',
            help='Technique to use for creating a single file (defaults to "naive")')
    parser.add_argument('-x', '--executable', action='store_true', help='make new script executable')

    args = parser.parse_args()
    #args = parser.parse_args(['./main.py', 'output.py'])

    concatenate(args.file, method=args.method, output=args.output)
